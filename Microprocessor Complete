`timescale 1ns / 1ps

module MPUwithMemoryUnit(input rst,clk,
input instrMem_enableExt,input instrMemRWExt,input[7:0]instrMem_addressExt,input[7:0]dataToInstrMemExt,output [7:0]instrMemDataOut,
input dataMem_enableExt,input dataMemRWExt,input[3:0]dataMem_addressExt,input[7:0]dataToDataMemExt,output [7:0]dataMemDataOut
);
//Inputs to Instruction Memory, En,RW,ADRESS,Datain
wire instrMem_enable,instrMem_RW;
wire [7:0] instrMem_address,dataIntoInstrMem; 


//En,RW,ADDRESS to Instruction Memory from MPU. No Data from MPU to Instruction Memory.
wire MPUenableinstrMem,instrMem_RWMPU;
wire [7:0]  instrMem_addressMPU;


//Inputs to ALU
wire [3:0]opcode;
wire [7:0]operand1_dataToDataMemMPU,operand2;

//ALU Output
wire [7:0]ALUout;

//an Input To MPU, multiplexed with ALU output and Data from Data Memory
wire [7:0]ALUcumdataMemDataOut;


//En,RW,ADDRESS to Data Memory from MPU. Data from MPU to Data Memory is in "operand1_dataToDataMemMPU" which is ALU inputs list
wire MPUenableDataMem,dataMem_RWMPU;
wire [3:0]dataMem_addressMPU;


//inputs of data Memory,En,RW,ADRESS,Datain
wire dataMem_enable,dataMem_RW;
wire [3:0]dataMem_address;
wire [7:0]dataToDataMem;




MuxForDataMemAndALU        MuxDataALU(ALUout,dataMemDataOut, MPUenableDataMem, ALUcumdataMemDataOut);








MuxForInstrMemBtwnExtAndMPU       MuxInstrExtMPU( rst,
 MPUenableinstrMem,instrMem_enableExt, instrMem_enable,
  instrMem_RWMPU,instrMemRWExt,instrMem_RW,
 instrMem_addressMPU,instrMem_addressExt,instrMem_address,
dataToInstrMemExt,dataIntoInstrMem);








MuxForDataMemBtwnExtAndMPU       MuxDataExtMPU(rst,
MPUenableDataMem,dataMem_enableExt, dataMem_enable,
 dataMem_RWMPU,dataMemRWExt,dataMem_RW,
 dataMem_addressMPU,dataMem_addressExt,dataMem_address,
operand1_dataToDataMemMPU,dataToDataMemExt,dataToDataMem);




controlunit         CU(rst,clk,
instrMemDataOut, MPUenableinstrMem
,instrMem_RWMPU, instrMem_addressMPU,
ALUcumdataMemDataOut, MPUenableDataMem,dataMem_RWMPU,dataMem_addressMPU,
opcode,operand1_dataToDataMemMPU,operand2);






 instruction_Memory       InstrMem(instrMem_enable, instrMem_RW, instrMem_address, dataIntoInstrMem, instrMemDataOut);
 
 
 
 
 
 
 data_Memory     dataMem(dataMem_enable,dataMem_RW,dataMem_address, dataToDataMem, dataMemDataOut);
 
 
 
 
 
 
 ALU       ALunit(
     operand1_dataToDataMemMPU,operand2,
     opcode,
     ALUout
    );
 
 
 
 
endmodule



module controlunit(input rst,clk,
input[7:0] instruction,output inst_enable,inst_RW,output[7:0] inst_address,
//ALU_datain=dataFromMemory and AluResult multiplexed
input[7:0] ALU_datain,output data_enable,data_RW,output[3:0]data_address,
//operand1_dataout=represents multiplexed signal
output [3:0]opcode,output reg [7:0] operand1_dataout,operand2);

reg [3:0]state;
reg [3:0]next_state;
reg [7:0]instr_reg;
reg [7:0]next_instr_reg;
  reg [7:0] regA,regB,regC,regD;
reg [7:0]program_counter;

parameter s0=4'd0,sfetch=4'd1,sdecode=4'd2,salu=4'd3,sld=4'd4,sst=4'd5,shlt=4'd6,halting_instr=8'd255;

always @(posedge clk)//incrementing Program Counter
begin
if(~rst) program_counter<=8'd0;
else program_counter<=(state==sfetch)?(program_counter+8'd1):program_counter;
end



always @(posedge clk)//state changing logic
begin
if(~rst) state<=s0;
else state<=next_state;
end

always @(posedge clk)//changing instruction register to new value
begin
instr_reg<=next_instr_reg;
end

always @(posedge clk)//registers value assignment
begin
regA<=(((state==salu)&(~(|instr_reg[3:2])))|(state==sld))?ALU_datain:regA;
  regB<=((state==salu)&((~instr_reg[3])&instr_reg[2]))?ALU_datain:regB;
  regC<=((state==salu)&(instr_reg[3]&(~instr_reg[2])))?ALU_datain:regC;
  regD<=((state==salu)&((&instr_reg[3:2])))?ALU_datain:regD;
end


always @*//next state value
begin 
case(state)
s0:next_state=sfetch;//rst?sfetch:s0;
sfetch:next_state=sdecode;
sdecode:next_state=((|instr_reg[7:5]))?salu:(instr_reg[4]?sst:sld);
// Checking for last instruction => 8'b11111111
salu:next_state=(&instr_reg)?shlt:sfetch;
sst:next_state=(&instr_reg)?shlt:sfetch;
sld:next_state=(&instr_reg)?shlt:sfetch;
shlt:next_state=shlt;
default:next_state=s0;
endcase
end

always @*//Instruction Register value i.e. to load new instruction or not
begin
case(state)
// Undefined state anyways, next_instr_reg doesn't matter
s0:next_instr_reg=8'd0;
sfetch:next_instr_reg=instruction;
default:next_instr_reg=instr_reg;
endcase
end

always @*//operand2 value 
begin
case((&instr_reg[7:6])|(instr_reg[7]&instr_reg[4])|((~(instr_reg[7]|instr_reg[6]|instr_reg[4]))&instr_reg[5]))
1'b1:operand2={{7{instr_reg[1]}},instr_reg[0]};
1'b0:
begin
case(instr_reg[1:0])
2'b00:operand2=regA;
2'b01:operand2=regB;
2'b10:operand2=regC;
2'b11:operand2=regD;
endcase
end
endcase
end

always @*//operand1_dataout value
begin
operand1_dataout=regA;
end



  assign inst_enable=(state==sfetch)?1'b1:1'b0,//instruction memory signals
inst_RW=1'b1, 
inst_address=program_counter;


  assign data_enable=((state==sld)|(state==sst))?1'b1:1'b0,//data memory signals
data_RW=(state==sst)?1'b0:1'b1,
data_address=instr_reg[3:0];

assign opcode=instr_reg[7:4];//giving opcode out for ALU operations

endmodule



module data_Memory (Enable, ReadWrite, Address, DataIn, DataOut);
input Enable, ReadWrite;
input [7: 0] DataIn;
input [3: 0] Address;
output reg [7: 0] DataOut;
reg [7: 0] instruction_Mem [0:15]; // 256 x 8 memory
  always @ (Enable,ReadWrite,Address,DataIn)
 if (Enable)
 if (ReadWrite) DataOut = instruction_Mem [Address]; // Read
 else instruction_Mem [Address] = DataIn; // Write
 else DataOut = 8'bz; // High impedance state
endmodule





module ALU(
    input [7: 0] Data1,
    input [7: 0] Data2,
    input [3: 0] OpCode,
    output reg [7: 0] OperationResult
    );
reg [7: 0] MoveResult;
reg [7: 0] AddResult;
reg [7: 0] SubtractResult;
reg [7: 0] ComplementResult;
reg [7: 0] AndResult;
reg [7: 0] OrResult;
reg [7: 0] XorResult;
always@(*) begin
    MoveResult = Data2;
    AddResult = Data1 + Data2;
    SubtractResult = Data1 - Data2;
    ComplementResult = ~ Data2;
    AndResult = Data1 & Data2;
    OrResult = Data1 | Data2;
    XorResult = Data1 ^ Data2;
  
    case(OpCode)
        // Move Register
        4'b0011: OperationResult = MoveResult;
        // Move Immediate
        4'b0010: OperationResult = MoveResult;
        // Sum Register
        4'b0100: OperationResult = AddResult;
        // Sum Immediate
        4'b1100: OperationResult = AddResult;
        // Subtract Register
        4'b0101: OperationResult = SubtractResult;
        // Subtract Immediate
        4'b1101: OperationResult = SubtractResult;
        // Complement Register
        4'b0111: OperationResult = ComplementResult;
        // Complement Immediate
        4'b1111: OperationResult = ComplementResult;
        // And Register
        4'b0110: OperationResult = AndResult;
        // And Immediate
        4'b1110: OperationResult = AndResult;
        // Or Register
        4'b1000: OperationResult = OrResult;
        // Or Immediate
        4'b1001: OperationResult = OrResult;
        // Xor Register
        4'b1010: OperationResult = XorResult;
        // Xor Immediate
        4'b1011: OperationResult = XorResult;
        // Default
        default: OperationResult = 8'bz;
    endcase
end
endmodule


module MuxForDataMemAndALU(input [7:0] ALUout,DataMem,input enable, output [7:0] alu_datain);
assign alu_datain=enable?DataMem:ALUout;
endmodule

module MuxForInstrMemBtwnExtAndMPU(input rst,
 input instrMem_enableMPU,instrMem_enableExt, output instrMem_enable,
 input instrMem_RWMPU,instrMem_RWExt,output instrMem_RW,
input[7:0] instrMem_addressMPU,instrMem_addressExt,output [7:0]instrMem_address,
input[7:0]dataToInstrMemExt,output[7:0]dataIntoInstrMem);

assign instrMem_enable=rst?instrMem_enableMPU:instrMem_enableExt,
instrMem_RW=rst?instrMem_RWMPU:instrMem_RWExt, 
instrMem_address=rst?instrMem_addressMPU:instrMem_addressExt,
dataIntoInstrMem=rst?8'd255:dataToInstrMemExt;
endmodule

module MuxForDataMemBtwnExtAndMPU(input rst,
input dataMem_enableMPU,dataMem_enableExt, output dataMem_enable,
 input dataMem_RWMPU,dataMem_RWExt,output dataMem_RW,
                                  input[3:0] dataMem_addressMPU,dataMem_addressExt,output [3:0]dataMem_address,
input[7:0]dataToDataMemMPU,dataToDataMemExt,output[7:0]dataToDataMem);

assign dataMem_enable=rst?dataMem_enableMPU:dataMem_enableExt,
dataMem_RW=rst?dataMem_RWMPU:dataMem_RWExt, 
dataMem_address=rst?dataMem_addressMPU:dataMem_addressExt,
dataToDataMem=rst?dataToDataMemMPU:dataToDataMemExt;

endmodule


module instruction_Memory (Enable, ReadWrite, Address, DataIn, DataOut);
input Enable, ReadWrite;
input [7: 0] DataIn;
input [7: 0] Address;
output reg [7: 0] DataOut;
reg [7: 0] instruction_Mem [0:255]; // 256 x 8 memory
always @ (Enable,ReadWrite,Address,DataIn)
 if (Enable)
 if (ReadWrite) DataOut = instruction_Mem [Address]; // Read
 else instruction_Mem [Address] = DataIn; // Write
 else DataOut = 8'bz; // High impedance state
endmodule
